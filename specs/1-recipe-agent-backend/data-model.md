# Data Model: Recipe Agent Backend

**Feature**: 1-recipe-agent-backend  
**Date**: December 1, 2025  

## Overview

This document defines the data structures used in the Recipe Agent Backend. All models use **Pydantic** for validation and serialization. Where possible, we leverage LangChain's built-in types.

**Reference**: https://reference.langchain.com/python/langchain/messages/

---

## LangChain Built-in Types (Use These)

### Messages

LangChain 1.0 provides built-in message types from `langchain.messages`:

```python
from langchain.messages import HumanMessage, AIMessage, SystemMessage

# Usage
messages = [
    SystemMessage(content="You are a helpful recipe assistant."),
    HumanMessage(content="How do I make an Old Fashioned?"),
    AIMessage(content="Here's how to make an Old Fashioned...")
]
```

| Class | Import | Description |
|-------|--------|-------------|
| `HumanMessage` | `langchain.messages` | Message from the user |
| `AIMessage` | `langchain.messages` | Message from the AI assistant |
| `SystemMessage` | `langchain.messages` | System prompt / AI behavior priming |
| `AIMessageChunk` | `langchain.messages` | Streaming response chunk |

**Note**: No custom Message class needed - use LangChain's built-in types.

### Conversation History

Conversation history is simply a `list` of LangChain message objects. No custom `ConversationSession` class needed:

```python
from langchain.messages import HumanMessage, AIMessage

# Conversation is just a list of messages
conversation: list[HumanMessage | AIMessage] = []

# Add messages as conversation progresses
conversation.append(HumanMessage(content="How do I make a mojito?"))
conversation.append(AIMessage(content="Here's the recipe..."))
```

---

## Custom Pydantic Models

### 1. RecipeType (Enum)

Enumeration for recipe categories.

```python
from enum import Enum

class RecipeType(str, Enum):
    COCKTAIL = "cocktail"
    FOOD = "food"
    DESSERT = "dessert"
```

---

### 2. AgentConfig

Configuration for the recipe agent using Pydantic.

```python
from pydantic import BaseModel, Field
from pathlib import Path

class AgentConfig(BaseModel):
    model: str = Field(
        default="anthropic:claude-sonnet-4-5-20250929",
        description="Model identifier (format: provider:model-name)"
    )
    prompt_file: Path = Field(
        default=Path("prompts/default.txt"),
        description="Path to system prompt file"
    )
    tools_enabled: list[str] = Field(
        default=["web_search", "youtube_transcript"],
        description="List of enabled tool names"
    )
    
    @property
    def system_prompt(self) -> str:
        """Load system prompt from file."""
        return self.prompt_file.read_text()
```

**Validation Rules**:
- `model` must be a valid model string (format: `provider:model-name`)
- `prompt_file` must exist and be readable
- `tools_enabled` must contain valid tool identifiers

---

### 3. Ingredient

Individual ingredient with quantity using Pydantic.

```python
from pydantic import BaseModel, Field

class Ingredient(BaseModel):
    name: str = Field(..., description="Ingredient name")
    quantity: str = Field(..., description="Amount (e.g., '2', '1/2')")
    unit: str | None = Field(default=None, description="Measurement unit (e.g., 'oz', 'cups')")
    notes: str | None = Field(default=None, description="Preparation notes (e.g., 'diced', 'chilled')")
```

**Fields**:
| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Ingredient name |
| `quantity` | string | Yes | Amount (e.g., "2", "1/2") |
| `unit` | string | No | Measurement unit (e.g., "oz", "cups") |
| `notes` | string | No | Preparation notes (e.g., "diced", "chilled") |

---

### 4. Recipe

Structured recipe output generated by the agent using Pydantic.

```python
from pydantic import BaseModel, Field

class Recipe(BaseModel):
    name: str = Field(..., description="Recipe name")
    recipe_type: RecipeType = Field(..., description="Type of recipe")
    ingredients: list[Ingredient] = Field(..., description="List of ingredients")
    instructions: list[str] = Field(..., description="Ordered preparation steps")
    prep_time: str | None = Field(default=None, description="Preparation time")
    cook_time: str | None = Field(default=None, description="Cooking time (for food)")
    servings: str | None = Field(default=None, description="Serving size")
    source_references: list[str] = Field(default_factory=list, description="Source URLs")
    notes: str | None = Field(default=None, description="Tips or variations")
```

**Fields**:
| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Recipe name |
| `recipe_type` | RecipeType | Yes | Enum: COCKTAIL, FOOD, DESSERT, etc. |
| `ingredients` | list[Ingredient] | Yes | Ingredient list with quantities |
| `instructions` | list[str] | Yes | Ordered preparation steps |
| `prep_time` | string | No | Preparation time (e.g., "10 minutes") |
| `cook_time` | string | No | Cooking time for food recipes |
| `servings` | string | No | Serving size (e.g., "4 servings", "1 cocktail") |
| `source_references` | list[str] | No | URLs or video IDs used as sources |
| `notes` | string | No | Additional tips or variations |

---

### 5. SearchResult (Tool Output)

Structured output from web search tool using Pydantic.

```python
from pydantic import BaseModel, Field

class SearchResult(BaseModel):
    title: str = Field(..., description="Page title")
    url: str = Field(..., description="Source URL")
    snippet: str = Field(..., description="Relevant text excerpt")
```

---

### 6. TranscriptResult (Tool Output)

Structured output from YouTube transcript tool using Pydantic.

```python
from pydantic import BaseModel, Field

class TranscriptResult(BaseModel):
    video_id: str = Field(..., description="YouTube video identifier")
    video_title: str | None = Field(default=None, description="Video title")
    transcript: str = Field(..., description="Full transcript text")
    duration_seconds: int | None = Field(default=None, description="Video duration")
```

---

## Entity Relationships

```
Agent (runtime)
    ├── uses → AgentConfig (loads prompt from file)
    ├── maintains → list[HumanMessage | AIMessage] (conversation history)
    ├── invokes → SearchResult (via web_search tool)
    └── invokes → TranscriptResult (via youtube_transcript tool)

Agent output
    └── generates → Recipe (containing Ingredients, using RecipeType enum)
```

---

## Message Flow

```
User Input → HumanMessage(content=input)
          → Agent Processing
          → [Optional] Tool Calls → Tool Results
          → AIMessage(content=response)
          → Display to User
```

---

## File Structure for Models

```
recipe_creator/
├── models/
│   ├── __init__.py      # Export all models
│   ├── recipe.py        # Recipe, Ingredient, RecipeType
│   ├── config.py        # AgentConfig
│   └── tools.py         # SearchResult, TranscriptResult
```

---

## Notes

- **Pydantic**: All custom models use Pydantic BaseModel for validation
- **LangChain Types**: Use built-in `HumanMessage`, `AIMessage`, `SystemMessage`
- **Prompt Loading**: System prompt loaded from file path specified in config
- **No Custom Session**: Conversation is just `list[HumanMessage | AIMessage]`
- **RecipeType Enum**: Provides type safety for recipe categorization
- **No Persistence**: All data structures are in-memory only

---

*Data model complete. Uses Pydantic for validation and LangChain built-in types for messages.*

